\documentclass[format=acmlarge, review=true, authordraft=true]{acmart}

%% scheme-list :
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}

\lstset{
  language=Scheme,
  basicstyle=\ttfamily,
  morekeywords={run,conde,run*,defrel,==,fresh},
  alsodigit={!\$\%&*+-./:<=>?@^_~},
  morecomment=[l]{;,\#{}lang},
  mathescape=true
}
%% scheme-list .

% metadata

\title{miniKanren with fair search strategies}
\author{Kuang-Chen Lu}
\affiliation{Indiana University}
\author{Weixi Ma}
\affiliation{Indiana University}
\author{Daniel P. Friedman}
\affiliation{Indiana University}



%%% NOTE %%%
%
% - deadline?
%
%   miniKanren workshop deadline May 15, 2018
%
%%%%%%%%%%%%


%TODO test cases: quine, '(I love you).

%TODO 1. reformat LaTeX (80 chars per line)
%TODO 2. stat quine
%TODO 3. keep writing

% Forget the issues about efficiency
% Read the monad paper




% body
\begin{document}

\begin{abstract}

The syntax of a programming language should reflect its semantics. When using a
disjunction operator in relational programming, a programmer would expect all
clauses of this disjunction to share the same chance of being explored, as
these clauses are written in parallel. The existing multiarity disjunctive
operator in miniKanren, however, prioritize its clauses by the order of which
these clauses are written down. We have devised two new search strategies that
% allocate computational effort fairly in all clauses.
allocate computational effort more fairly in all clauses.

\end{abstract}

\maketitle

\section{introduction}

When every sub-goal of a disjunction produces infinite states, the existing 
disjunctive operator allocates half computational effort to its first goal, 
quater to the second, eighth to the third, and so on. The unfairness provides 
both opportunity and burden: miniKanren users can place more frequently used 
goal at the beginning to optimize their programs; however, it might be a 
catastrophe if a goal that generate many useless partial solution is placed 
before more important goals. Seasoned miniKanreners usually know how to utilize 
the unfairness to optimize their programs. However, we believe search strategies 
that is less sensitive to goal order can also be useful to little miniKanreners 
as well as seansoned ones. We propose two such search strategies, balanced 
interleaving DFS (biDFS) and breadth-first search (BFS), and observe how they 
affect the efficiency and the answer order of known miniKanren programs. The 
experiment is conducted with the miniKanren from \textit{The Reasoned Schemer, 
2nd Edition}.

\subsection{fairness}

A disjunction is fair if when a corresponding goal is queried, answers of 
lower costs come first. The \emph{cost} of an answer the number of relation 
applications needed to find the answer. This idea is borrowed from Silvija 
Seres's work [*].

Interleaving DFS, the search strategy of TRS2 miniKanren, is not fair. Among 
the search strategies we devised, biDFS is not fair, but is more fair than 
iDFS. And BFS is fair.

\subsection{related works}

The unfairness of disjunction has been noticed by Seres et al. Their complete 
and fair search strategy is also named breadth-first search. Their BFS 
is fair and is similar to ours. However, their Haskell implementation cannot be 
translated to Scheme directly. This is partially due to the difference if 
calling convensions of host languages. Another reason is that their search 
space are infinite even when no answers exists. This is not feasible 
in miniKanren, where users can query all answers. 

% TODO: summarize following sections) Section 2 explains why iDFS biases toward 
% left \texttt{conde} clauses. Section 3 is about the biDFS. Section 4 is 
% about BFS.

\section{representation of search space}

``Stream'' is often used to name the representation of search space in 
miniKanren. However, the search space is more like a stream of list, 
because the information that a stream has no \texttt{car} is employed in all 
complete miniKanren search strategies to redirect search effort. If the search 
space is a normal stream, the information should have been used in a more 
trivial way. 

In the rest of this paper, we call the \texttt{car}s of a stream 
its \textit{mature part}, and the last \texttt{cdr} its \textit{immature part}.

\section{why disj is unfair}

The multiarity disjuction operator \texttt{disj} combine its sub-goals with 
\texttt{disj2}, right associatively. \texttt{disj2} is fair in the sence that 
it allocates computational effort evenly to its two sub-goals. Unfortunately, 
the way how \texttt{disj2} achieves fairness leads to the unfairness of 
\texttt{disj}. The core functionality of \texttt{disj2} is completed by 
\texttt{append-inf} (Fig.~ref{disj2-and-append-inf}). When both input streams 
are infinite, the resulting mature part contains only the mature part of 
\texttt{s-inf}. The whole \texttt{t-inf} goes to the resulting immature part. 
However, \texttt{t-inf} and \texttt{s-inf} are swapped in the delayed recursive 
call. Hence the search strategy spend computational effort evenly in two 
appended streams. As \texttt{disj} applys \texttt{disj2} right associatively, 
the left clauses are more frequently explored.

\begin{figure}
  \lstinputlisting{Figures/disj2.rkt}
  \caption{\texttt{disj2} and \texttt{append-inf}}
  \label{disj2-and-append-inf}
\end{figure}
 
\section{balanced interleaving DFS}

A \texttt{conde} expression looks like a binary tree, if we consider 
\texttt{disj2}s as internal nodes and \texttt{conde} clauses as a terminal 
nodes. In fact, each of them is one of the most unbalanced binary trees. The 
basic idea of our first solution, balanced interleaving DFS, is to make the 
tree balanced. We introduce a function \texttt{disj*} and its helper 
\texttt{split} (Fig.~\ref{disj*}). \texttt{disj*} essentially construct a 
balanced \texttt{disj2} tree. \texttt{split} splits elements of \texttt{ls} 
into two even half and pass them to the continuation parameter \texttt{k}.

\begin{figure}
  \lstinputlisting{Figures/disj*.rkt}
  \caption{\texttt{disj*}}
  \label{disj*}
\end{figure}

\section{breadth-first search}

In this section we change the search strategy to \textit{breadth-first search} 
and optimize it. The whole process is completed in two steps. In the first 
step, from mk-0 to mk-1, BFS is introduced. In the second step, mk-1 to mk-3, 
BFS is optimized. The initial version, \texttt{mk-0}, is exactly the version in 
\emph{The Reasoned Schemer, 2nd Edition}.

\subsection{cost of answers}

%TODO the meaning of resolution step in Silvija Seres's paper

Now we illustrate the costs of answers by running a miniKanren relation.
Fig.~\ref{def-repeato} defines the relation \texttt{repeato} that 
relates a term \texttt{x} with a list whose elements are all \texttt{x}s.

\begin{figure}
  \lstinputlisting{Figures/defrel-repeato.rkt}
  \caption{\texttt{repeato}}
  \label{def-repeato}
\end{figure}

Consider the following \texttt{run} of \texttt{repeato}.
\begin{center}
  \begin{tabular}{c}
  \lstinputlisting{Figures/run-repeato-1.rkt}
   \end{tabular}
\end{center}

The above \texttt{run} generates 4 answers. All are lists of \texttt{*}s.
The order of the answers reflects the order miniKanren discovers them:
the first answer in the list is first discovered. This result is not suprising:
to generate the first answer, \texttt{'()}, miniKanren needs to apply
\texttt{repeato} only once and the later answers need more recursive
applications. In this example, the cost of each answer is the same as
one more than the number of \texttt{*}s: the cost of \texttt{'()} is 1,
the cost of \texttt{'(*)} is 2, and so on.

A list of answer is in the \emph{cost-respecting} order if no answer occurs
before another answer of a lower cost. In the above example, the answers are
cost-respecting. The iDFS search, however, does not generate cost-respecting
answers in general. As an example, consider the following \texttt{run} of
\texttt{repeato}.
\begin{center}
  \begin{tabular}{c}
   \lstinputlisting{Figures/run-conde-repeato-iDFS.rkt}
   \end{tabular}
\end{center}

The results are not cost-respecting. For example, \texttt{'(a a)} occurs before
\texttt{'(b)} while \texttt{'(a a)} is associated with a higher cost. 
iDFS strategy is the cause, since it prioritizes the first \texttt{conde} case
considerablely. When every \texttt{conde} case are equally productive, the iDFS
strategy takes $1/2^{i}$ answers from the $i$-th case, except the last case,
which share the same portion as the second last one.

%TODO relation *application*

For the above \texttt{run}, both search strategies produces answers in 
increasing order of costs, i.e. both of them are \emph{cost-respecting}. In 
more complicated cases, however, interleaving DFS might not produce answers in 
cost-repecting order. For instance, with iDFS the \texttt{run} in Fig.~
\ref{conde-repeato-iDFS} produces answers in a seemingly random order. In 
contrast, the same run with BFS produces answers in an expected order (Fig.~
\ref{conde-repeato-BFS}).

\lstinputlisting{Figures/run-conde-repeato-BFS.rkt}

\subsection{from \texttt{mk-0} to \texttt{mk-1}}

In \texttt{mk-0} and \texttt{mk-1}, search spaces are represented by streams of 
answers. Streams can be finite or infinite. Finite streams are just lists. And 
infinite streams are improper lists, whose last \texttt{cdr} is a thunk 
returning another stream. We call the \texttt{car}s the \emph{mature} part, and 
the last \texttt{cdr} the \emph{immature} part. 

Streams are cost respective when they are initially constructed by \texttt{==}. 
However, the \texttt{mk-0} version of \texttt{append-inf} (Fig.~\ref{append-
inf-0}) breaks cost respectiveness if its first input stream, \texttt{s-inf}, 
is infinite. The resulting mature part contains only the mature part of 
\texttt{s-inf}. The whole \texttt{t-inf} goes to the resulting immature part.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-0.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-0}}
	 \label{append-inf-0}
\end{figure}

The \texttt{mk-1} version of \texttt{append-inf} (Fig.~\ref{append-inf-1}) 
restores cost-respectiveness by combining the mature parts in the fashion of 
\texttt{append}. This \texttt{append-inf} calls its helper immediately, with 
the first argument, \texttt{s?}, set to \texttt{\#{}t}, which means \texttt{s-
inf} in the helper is the \texttt{s-inf} in the driver. Two streams are swapped 
in the third \texttt{cond} clause, with \texttt{s?} flipped accordingly.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-1.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-1}}
	 \label{append-inf-1}
\end{figure}

\texttt{mk-1} is not efficient in two aspects. \texttt{append-inf} need to copy 
all \texttt{cons} cells of two input streams when the first stream has a non-
trivial immature part. Besides, \texttt{mk-1} computes answers of the same cost 
at once, even when only a portion is queried. We solves the two problems in the 
next subsections.

\subsection{\texttt{mk-3}, optimized breadth-first search}

We avoid generating same-cost answers at once by expressing BFS with a queue. 
The elements of the queue are delayed computation, represented by thunks. Every 
\texttt{mk-1} stream has zero or one thunk, so we have no interesting way to 
manage it. Therefore we change the representation of immature parts from thunks 
to lists of thunks. As as consequence, we also change the way to combine mature 
and immature part from \texttt{append} to \texttt{cons}. 

After applying this two changes, stream representation becomes more 
complicated. It motivates us to set up an interface between stream functions 
and the rest of miniKanren. Listed in Fig.~\ref{interface} are all functions 
being aware of the stream representation, but \texttt{take-inf} and its helper 
function, which is explained later. The first three functions are constructors: 
\texttt{empty-inf} constructs an empty stream; \texttt{unit-mature-inf} 
constructs a stream with one mature solution; \texttt{unit-immature-inf} 
constructs a stream with one thunk. The \texttt{append-inf} in \texttt{mk-3} is 
relatively straightforwared compared with the \texttt{mk-1} version. 
\texttt{append-map-inf} is more tricky on how to construct the new immature 
part. We can follow the approach in mk-0 and mk-1 -- create a new thunk which 
invoke append-map-inf recursively when forced. But then we need to be careful: 
if we construct the thunk when the old immature part is an empty list, the 
resulting stream might be infinitely unproductive. Beside, all solutions of the 
next lowest cost in \texttt{s-inf} must be computed when the thunk is invoked. 
However sometimes only a portion of these solutions is required to answer a 
query. To avoid the trouble and the advanced computation, we choose to create a 
new thunk for every existing thunk. The next four functions are used only by 
\texttt{ifte} and \texttt{once}. Uninterested readers might skip them. 
\texttt{null-inf?} checks whether a stream is exausted. \texttt{mature-inf?} 
checks whether a stream has some mature solutions. \texttt{car-inf} takes the 
first solution out of a mature stream. \texttt{cdr-inf} drops the first 
solution of a mature stream. Finally, \texttt{force-inf} forces an a immature 
stream to do more computation.

\begin{figure}
	 \lstinputlisting{Figures/interface.rkt}	
	 \caption{Functions being aware of stream representation}
	 \label{interface}
\end{figure}


The last interesting function is \texttt{take-inf} (Fig.~\ref{take-inf-3-1}). 
The parameter \texttt{vs} is a list of solutions. The next two parameters, 
\texttt{P} and \texttt{Q}, together represent a queue. The first two 
\texttt{cond} lines are very similar to their counterparts in mk-0 and mk-1. 
The third line runs when we exaust all solutions. The forth line re-shape the 
queue. The fifth and last line invoke the first thunk in the queue and use the 
mature part of the resulting stream, \texttt{s-inf}, as the new \texttt{vs}, 
and enqueuing \texttt{s-inf}'s thunks.

\begin{figure}
	 \lstinputlisting{Figures/take-inf-3-1.rkt}	
	 \caption{\texttt{take-inf} in \texttt{mk-3-1}}
	 \label{take-inf-3-1}
\end{figure}



\section{conclusion}

\section*{acknowledgments}

\section*{references}

\end{document}

