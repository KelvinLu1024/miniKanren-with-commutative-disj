\documentclass[format=acmlarge, review=true, authordraft=true]{acmart}

%% scheme-list :
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}

\lstset{
  language=Scheme,
  basicstyle=\ttfamily,
  morekeywords={run,conde,run*,defrel,==,fresh},
  alsodigit={!\$\%&*+-./:<=>?@^_~},
  morecomment=[l]{;,\#{}lang},
  mathescape=true
}
%% scheme-list .

% metadata

\title{BFS search in miniKanren}
\author{Kuang-Chen Lu}
\affiliation{Indiana University}
\author{Weixi Ma}
\affiliation{Indiana University}
\author{Daniel P. Friedman}
\affiliation{Indiana University}



%%% NOTE %%%
%
% - deadline?
%
%   miniKanren workshop deadline May 15, 2018
%
%%%%%%%%%%%%



% body
\begin{document}

\begin{abstract}

The syntax of a programming language should reflect its semantics.
When using a disjunction operator in relational programming, a programmer would
expect all clauses of this disjunction to share the same chance of being explored,
as these clauses are written in parallel. The existing disjunctive operators in miniKanren,
however, prioritize their clauses by the order of which these clauses are written down.
We have devised a new search strategy that searches evenly in all clauses.
Based on our statistics, miniKanren slows down by a constant factor after applying our search strategy.
(tested with very-recursiveo, need more tests)


\end{abstract}

\maketitle

\section{introduction}

miniKanren is a relational programming language embedable in many languages[cite
miniKanren.org?]. 

The version of miniKanren in \textit{The Reasoned Schemer, 2nd Edition} features
an efficient and complete search strategy -- interleaving depth-first search (iDFS).
iDFS biases toward left conde lines. So miniKanren programmers sometimes need to
organize their conde lines carefully. We proposed two search strategies and their
implementations. The first strategy is breadth-first search. The second one is a
modified iDFS.

OUTLINE:

( About miniKanren )

( Why the left clauses are explored more frequently? )

%TODO define iDFS = interleaving DFS in Introduction

( How to solve the problem? )

( Summary of later sections )

\section{cost of answers}

%TODO the meaning of resolution step in Silvija Seres's paper

The \emph{cost} of an answer is the number of relation applications needed to
find the answer. This idea is borrowed from Silvija Seres's work [*].
Now we illustrate the costs of answers by running a miniKanren relation.
Fig.~\ref{def-repeato} defines the relation \texttt{repeato} that 
relates a term \texttt{x} with a list whose elements are all \texttt{x}s.

\begin{figure}
  \lstinputlisting{Figures/defrel-repeato.rkt}
  \caption{\texttt{repeato}}
  \label{def-repeato}
\end{figure}

Consider the following \texttt{run} of \texttt{repeato}.
\begin{center}
  \begin{tabular}{c}
  \lstinputlisting{Figures/run-repeato-1.rkt}
   \end{tabular}
\end{center}

The above \texttt{run} generates 4 answers. All are lists of \texttt{*}s.
The order of the answers reflects the order miniKanren discovers them:
the leftmost answer is the first one. This result is not suprising:
to generate the first answer, \texttt{'()}, miniKanren needs to apply
\texttt{repeato} only once and the later answers need more recursive
applications. In this example, the cost of each answer is the same as
one more than the number of \texttt{*}s: the cost of \texttt{'()} is 1,
the cost of \texttt{'(*)} is 2, and so on.

A list of answer is in the \emph{cost-respecting} order if no answer occurs
before another answer of a lower cost. In the above example, the answers are
cost-respecting. The iDFS search, however, does not generate cost-respecting
answers in general. As an example, consider the following \texttt{run} of
\texttt{repeato}.
\begin{center}
  \begin{tabular}{c}
   \lstinputlisting{Figures/run-conde-repeato-iDFS.rkt}
   \end{tabular}
\end{center}

The results are not cost-respecting. For example, \texttt{'(a a)} occurs before
\texttt{'(b)} while \texttt{'(a a)} is associated with a higher cost. 
The problem is that iDFS strategy prioritizes the first \texttt{conde} case
considerablely. In general, when every conde case are equally productive, the iDFS
strategy takes $1/2^{i}$ answers from the $i$-th case, except the last case,
which share the same portion as the second last one.

%TODO relation *application*

For the above \texttt{run}, both search strategies produces answers in increasing
order of costs, i.e. both of them are \emph{cost-respecting}. In more complicated
cases, however, interleaving DFS might not produce answers in cost-repecting order.
For instance, with iDFS the \texttt{run} in Fig.~\ref{conde-repeato-iDFS} produces
answers in a seemingly random order. In contrast, the same run with BFS produces
answers in an expected order (Fig.~\ref{conde-repeato-BFS}).

\lstinputlisting{Figures/run-conde-repeato-BFS.rkt}

\section{breadth-first search}

In this section we change the search strategy to breadth-first search and optimize it. The whole process is completed in three steps, corresponding to 3 versions of miniKanren. We start with, \texttt{mk-0}, the miniKanren in \emph{The Reasoned Schemer, 2nd Edition}.

\subsection{from \texttt{mk-0} to \texttt{mk-1}}

In \texttt{mk-0} and \texttt{mk-1}, search spaces are represented by streams of answers. Streams can be finite or infinite. Finite streams are just lists. And infinite streams are improper lists, whose last \texttt{cdr} is a thunk returning another stream. We call the \texttt{car}s the \emph{mature} part, and the last \texttt{cdr} the \emph{immature} part. 

Streams are cost respective when they are initially constructed by \texttt{==}. However, the \texttt{mk-0} version of \texttt{append-inf} (Fig.~\ref{append-inf-0}) breaks cost respectiveness when its first argument, \texttt{s-inf}, is infinite. The resulting mature part contains only the mature part of \texttt{s-inf}. The whole \texttt{t-inf} goes to the resulting immature part.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-0.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-0}}
	 \label{append-inf-0}
\end{figure}

The \texttt{mk-1} version of \texttt{append-inf} (Fig.~\ref{append-inf-1}) restores cost-respectiveness by combining the mature parts in the fashion of \texttt{append}. This \texttt{append-inf} calls its helper immediately, with the first argument, \texttt{s?}, set to \texttt{\#{}t}, which means \texttt{s-inf} in the helper is the \texttt{s-inf} in the driver. Two streams are swapped in the third \texttt{cond} clause, where \texttt{s?} is also changed accordingly.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-1.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-1}}
	 \label{append-inf-1}
\end{figure}

\texttt{mk-1} is not efficient in two aspects. \texttt{append-inf} need to copy all \texttt{cons} cells of two input streams when the first stream has a non-trivial immature part. Besides, \texttt{mk-1} computes answers of the same cost at once, even when only a portion is queried. We solves the two problems in the next subsections.

\subsection{\texttt{mk-3}, optimized breadth-first search}

We avoid generating same-cost answers at once by expressing BFS with a queue. The elements of the queue are delayed computation, represented by thunks. Every \texttt{mk-1} stream has zero or one thunk, so we have no interesting way to manage it. Therefore we change the representation of immature parts from thunks to lists of thunks. As as consequence, we also change the way to combine mature and immature part from \texttt{append} to \texttt{cons}. 

After applying this two changes, stream representation becomes more complicated. It motivates us to set up an interface between stream functions and the rest of miniKanren. Listed in Fig.~\ref{interface} are all functions being aware of the stream representation, but \texttt{take-inf} and its helper function, which is explained later. The first three functions are constructors: \texttt{empty-inf} constructs an empty stream; \texttt{unit-mature-inf} constructs a stream with one mature solution; \texttt{unit-immature-inf} constructs a stream with one thunk. The \texttt{append-inf} in \texttt{mk-3} is relatively straightforwared compared with the \texttt{mk-1} version. \texttt{append-map-inf} is more tricky on how to construct the new immature part. We can follow the approach in mk-0 and mk-1 -- create a new thunk which invoke append-map-inf recursively when forced. But then we need to be careful: if we construct the thunk when the old immature part is an empty list, the resulting stream might be infinitely unproductive. Beside, all solutions of the next lowest cost in \texttt{s-inf} must be computed when the thunk is invoked. However sometimes only a portion of these solutions is required to answer a query. To avoid the trouble and the advanced computation, we choose to create a new thunk for every existing thunk. The next four functions are used only by \texttt{ifte} and \texttt{once}. Uninterested readers might skip them. \texttt{null-inf?} checks whether a stream is exausted. \texttt{mature-inf?} checks whether a stream has some mature solutions. \texttt{car-inf} takes the first solution out of a mature stream. \texttt{cdr-inf} drops the first solution of a mature stream. Finally, \texttt{force-inf} forces an a immature stream to do more computation.

\begin{figure}
	 \lstinputlisting{Figures/interface.rkt}	
	 \caption{Functions being aware of stream representation}
	 \label{interface}
\end{figure}


The last interesting function is \texttt{take-inf} (Fig.~\ref{take-inf-3-1}). The parameter \texttt{vs} is a list of solutions. The next two parameters together represents a functional queue in a typical way. The first two \texttt{cond} lines are very similar to their counterparts in mk-0 and mk-1. The third line runs when we exaust all solutions. The forth line re-shape the queue. The fifth and last line invoke the first thunk in the queue and use the mature part of the resulting stream, \texttt{s-inf}, as the new \texttt{vs}, and enqueuing \texttt{s-inf}'s thunks.

\begin{figure}
	 \lstinputlisting{Figures/take-inf-3-1.rkt}	
	 \caption{\texttt{take-inf} in \texttt{mk-3-1}}
	 \label{take-inf-3-1}
\end{figure}



\section{conclusion}

\section*{acknowledgments}

\section*{references}

\end{document}

