\documentclass[format=acmlarge, review=true, authordraft=true]{acmart}

%% scheme-list :
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}

\lstset{
  language=Scheme,
  basicstyle=\ttfamily,
  morekeywords={run,conde,run*,defrel,==,fresh},
  alsodigit={!\$\%&*+-./:<=>?@^_~},
  morecomment=[l]{;,\#{}lang},
  mathescape=true
}
%% scheme-list .

% metadata

\title{miniKanren with fair search strategies}
\author{Kuang-Chen Lu}
\affiliation{Indiana University}
\author{Weixi Ma}
\affiliation{Indiana University}
\author{Daniel P. Friedman}
\affiliation{Indiana University}



%%% NOTE %%%
%
% - deadline?
%
%   miniKanren workshop deadline May 15, 2018
%
%%%%%%%%%%%%


%TODO test cases: quine, '(I love you).

%TODO 1. reformat LaTeX (80 chars per line)
%TODO 2. stat quine
%TODO 3. keep writing

% Forget the issues about efficiency
% Read the monad paper




% body
\begin{document}

\begin{abstract}

The syntax of a programming language should reflect its semantics. When using a
disjunction operator in relational programming, a programmer would expect all
clauses of this disjunction to share the same chance of being explored, as
these clauses are written in parallel. The existing multiarity disjunctive
operator in miniKanren, however, prioritize its clauses by the order of which
these clauses are written down. We have devised two new search strategies that
% allocate computational effort fairly in all clauses.
allocate computational effort more fairly in all clauses.

\end{abstract}

\maketitle

\section{introduction}

When every sub-goal of a disjunction produces infinite states, the existing 
disjunctive operator allocates half computational effort to its first goal, 
quater to the second, eighth to the third, and so on. The unfairness provides 
both opportunity and burden: miniKanren users can place more frequently used 
goal at the beginning to optimize their programs; however, it might be a 
catastrophe if a goal that generate many useless partial solution is placed 
before more important goals. Seasoned miniKanreners usually know how to utilize 
the unfairness to optimize their programs. However, we believe search strategies 
that is less sensitive to goal order can also be useful to little miniKanreners 
as well as seansoned ones. We propose two such search strategies, balanced 
interleaving DFS (biDFS) and breadth-first search (BFS), and observe how they 
affect the efficiency and the answer order of known miniKanren programs. The 
experiment is conducted with the miniKanren from \textit{The Reasoned Schemer, 
2nd Edition}.

\section{related works}

The unfairness of disjunction has been noticed by Seres et al. Their complete 
and fair search strategy is also named breadth-first search. Their BFS 
is fair and is similar to ours. However, their Haskell implementation cannot be 
translated to Scheme directly. This is partially due to the difference in 
calling convensions of host languages. Besides, their search space are infinite 
even when no answers exists. This is not feasible in miniKanren, where 
users can query all answers.



\section{fairness}

% KC: I changed the cost definition from ``... needed to *find* the answer''
%                                     to ``... needed to *verify* the answer''

A disjunction is fair if when a corresponding goal is queried, answers of 
lower costs come first. The \emph{cost} of an answer the number of relation 
applications needed to verify the answer. Now we illustrate the costs of answers 
by running a miniKanren relation. Fig.~\ref{def-repeato} defines the relation 
\texttt{repeato} that relates a term \texttt{x} with a list whose elements are 
all \texttt{x}s.

% COmmented out: This idea is borrowed from Silvija Seres's work [*].
% KC: Seres didn't phrase it this way.
%   We might need to compare our definition with Seres's one, instead of 
%   saying the idea is borrowed.

\begin{figure}
  \lstinputlisting{Figures/defrel-repeato.rkt}
  \caption{\texttt{repeato}}
  \label{def-repeato}
\end{figure}

Consider the following \texttt{run} of \texttt{repeato}.
\begin{center}
  \begin{tabular}{c}
  \lstinputlisting{Figures/run-repeato-1.rkt}
   \end{tabular}
\end{center}

The above \texttt{run} generates 4 answers. All are lists of \texttt{*}s.
The order of the answers reflects the order miniKanren discovers them:
the first answer in the list is first discovered. This order is not suprising:
to generate the first answer, \texttt{'()}, miniKanren needs to apply
\texttt{repeato} only once and the later answers need more recursive
applications. In this example, the cost of each answer is the same as
one more than the number of \texttt{*}s: the cost of \texttt{'()} is 1,
the cost of \texttt{'(*)} is 2, and so on.

A query result (list of answers) is in the \emph{cost-respecting} order if no 
answer occurs before another answer of a lower cost. In the above example, the 
result is cost-respecting. The iDFS search, however, does not generate 
cost-respecting answers in general. As an example, consider the following 
\texttt{run} of \texttt{repeato}.

\begin{center}
  \begin{tabular}{c}
   \lstinputlisting{Figures/run-conde-repeato-iDFS.rkt}
   \end{tabular}
\end{center}

The results is not cost-respecting. For example, \texttt{'(a a)} occurs before
\texttt{'(b)} while \texttt{'(a a)} is associated with a higher cost. 
iDFS strategy is the cause, since it prioritizes the first \texttt{conde} case
considerablely. When every \texttt{conde} case are equally productive, the iDFS
strategy takes $1/2^{i}$ answers from the $i$-th case, except the last case,
which share the same portion as the second last one. In contrast, the same run 
with BFS produces answers in an expected order.

\begin{center}
  \begin{tabular}{c}
   \lstinputlisting{Figures/run-conde-repeato-BFS.rkt}
   \end{tabular}
\end{center}


% \section{representation of search space}
% 
% ``Stream'' is often used to name the representation of search space in 
% miniKanren. However, the search space is more like a stream of list, because the 
% information that a stream is thunk is employed to redirect search effort. If the 
% search space is a normal stream, the information should have been used in a more 
% trivial way. 
% 
% In the rest of this paper, we call the \texttt{car}s of a stream 
% its \textit{mature part}, and the last \texttt{cdr} its \textit{immature part}.
% 
% \section{why disj is unfair}
% 
% The multiarity disjuction operator \texttt{disj} combine its sub-goals with 
% \texttt{disj2}, right associatively. Interestingly, although \texttt{disj} is 
% unfair, \texttt{disj2} is fair. The core functionality of \texttt{disj2} is 
% completed by \texttt{append-inf} (Fig.~ref{disj2-and-append-inf}). When both 
% input streams are infinite, the resulting mature part contains only the mature 
% part of \texttt{s-inf}. The whole \texttt{t-inf} goes to the resulting immature 
% part. However, \texttt{t-inf} and \texttt{s-inf} are swapped in the delayed 
% recursive call. Hence the search strategy spend computational effort evenly in 
% two appended streams. As \texttt{disj} applys \texttt{disj2} right 
% associatively, the left clauses are more frequently explored.
% 
% \begin{figure}
%   \lstinputlisting{Figures/disj2.rkt}
%   \caption{\texttt{disj2} and \texttt{append-inf}}
%   \label{disj2-and-append-inf}
% \end{figure}
 
\section{balanced interleaving DFS}

Our first solution, balanced interleaving DFS, is based on the observation that 
a disjuction can be viewed as a binary tree, where \texttt{disj2}s are nodes 
and sub-goals are leaves. In iDFS, the tree is in one of the most unbalanced 
forms, because \texttt{disj} applys \texttt{disj2} right associatively. As 
\texttt{disj2} allocates computational effort interleavingly to its two 
sub-goals, a disjunction allocates half computational effort to its first 
sub-goal, quater to the second, eighth to the third, and so on.

The key idea of biDFS is to make disjunction trees balanced 
(Fig.~\ref{balanced-disj}). We introduce a function \texttt{disj*} and its 
helper \texttt{split}, and change the \texttt{disj} macro to call 
\texttt{disj*} immediately. \texttt{disj*} essentially construct a balanced 
\texttt{disj2} tree. The \texttt{split} helper splits elements of \texttt{ls} 
into two lists of roughly the same length, then apply \texttt{k} to them.

\begin{figure}
  \lstinputlisting{Figures/balanced-disj.rkt}
  \caption{\texttt{balanced-disj}}
  \label{balanced-disj}
\end{figure}

\section{breadth-first search}

In this section we change the search strategy to \textit{breadth-first search} 
and optimize it. The whole process is completed in two steps. In the first 
step, from mk-0 to mk-1, BFS is introduced. In the second step, mk-1 to mk-3, 
BFS is optimized. The initial version, \texttt{mk-0}, is exactly the version in 
\emph{The Reasoned Schemer, 2nd Edition}.

\subsection{from \texttt{mk-0} to \texttt{mk-1}}

In \texttt{mk-0} and \texttt{mk-1}, search spaces are represented by streams of 
answers. Streams can be finite or infinite. Finite streams are just lists. And 
infinite streams are improper lists, whose last \texttt{cdr} is a thunk 
returning another stream. We call the \texttt{car}s the \emph{mature} part, and 
the last \texttt{cdr} the \emph{immature} part. 

Streams are cost respective when they are initially constructed by \texttt{==}. 
However, the \texttt{mk-0} version of \texttt{append-inf} (Fig.~\ref{append-
inf-0}) breaks cost respectiveness if its first input stream, \texttt{s-inf}, 
is infinite. The resulting mature part contains only the mature part of 
\texttt{s-inf}. The whole \texttt{t-inf} goes to the resulting immature part.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-0.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-0}}
	 \label{append-inf-0}
\end{figure}

The \texttt{mk-1} version of \texttt{append-inf} (Fig.~\ref{append-inf-1}) 
restores cost-respectiveness by combining the mature parts in the fashion of 
\texttt{append}. This \texttt{append-inf} calls its helper immediately, with 
the first argument, \texttt{s?}, set to \texttt{\#{}t}, which means \texttt{s-
inf} in the helper is the \texttt{s-inf} in the driver. Two streams are swapped 
in the third \texttt{cond} clause, with \texttt{s?} flipped accordingly.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-1.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-1}}
	 \label{append-inf-1}
\end{figure}

\texttt{mk-1} is not efficient in two aspects. \texttt{append-inf} need to copy 
all \texttt{cons} cells of two input streams when the first stream has a non-
trivial immature part. Besides, \texttt{mk-1} computes answers of the same cost 
at once, even when only a portion is queried. We solves the two problems in the 
next subsections.

\subsection{\texttt{mk-3}, optimized breadth-first search}

We avoid generating same-cost answers at once by expressing BFS with a queue. 
The elements of the queue are delayed computation, represented by thunks. Every 
\texttt{mk-1} stream has zero or one thunk, so we have no interesting way to 
manage it. Therefore we change the representation of immature parts from thunks 
to lists of thunks. As as consequence, we also change the way to combine mature 
and immature part from \texttt{append} to \texttt{cons}. 

After applying this two changes, stream representation becomes more 
complicated. It motivates us to set up an interface between stream functions 
and the rest of miniKanren. Listed in Fig.~\ref{interface} are all functions 
being aware of the stream representation, but \texttt{take-inf} and its helper 
function, which is explained later. The first three functions are constructors: 
\texttt{empty-inf} constructs an empty stream; \texttt{unit-mature-inf} 
constructs a stream with one mature solution; \texttt{unit-immature-inf} 
constructs a stream with one thunk. The \texttt{append-inf} in \texttt{mk-3} is 
relatively straightforwared compared with the \texttt{mk-1} version. 
\texttt{append-map-inf} is more tricky on how to construct the new immature 
part. We can follow the approach in mk-0 and mk-1 -- create a new thunk which 
invoke append-map-inf recursively when forced. But then we need to be careful: 
if we construct the thunk when the old immature part is an empty list, the 
resulting stream might be infinitely unproductive. Beside, all solutions of the 
next lowest cost in \texttt{s-inf} must be computed when the thunk is invoked. 
However sometimes only a portion of these solutions is required to answer a 
query. To avoid the trouble and the advanced computation, we choose to create a 
new thunk for every existing thunk. The next four functions are used only by 
\texttt{ifte} and \texttt{once}. Uninterested readers might skip them. 
\texttt{null-inf?} checks whether a stream is exausted. \texttt{mature-inf?} 
checks whether a stream has some mature solutions. \texttt{car-inf} takes the 
first solution out of a mature stream. \texttt{cdr-inf} drops the first 
solution of a mature stream. Finally, \texttt{force-inf} forces an a immature 
stream to do more computation.

\begin{figure}
	 \lstinputlisting{Figures/interface.rkt}	
	 \caption{Functions being aware of stream representation}
	 \label{interface}
\end{figure}


The last interesting function is \texttt{take-inf} (Fig.~\ref{take-inf-3-1}). 
The parameter \texttt{vs} is a list of solutions. The next two parameters, 
\texttt{P} and \texttt{Q}, together represent a queue. The first two 
\texttt{cond} lines are very similar to their counterparts in mk-0 and mk-1. 
The third line runs when we exaust all solutions. The forth line re-shape the 
queue. The fifth and last line invoke the first thunk in the queue and use the 
mature part of the resulting stream, \texttt{s-inf}, as the new \texttt{vs}, 
and enqueuing \texttt{s-inf}'s thunks.

\begin{figure}
	 \lstinputlisting{Figures/take-inf-3-1.rkt}	
	 \caption{\texttt{take-inf} in \texttt{mk-3-1}}
	 \label{take-inf-3-1}
\end{figure}



\section{conclusion}

\section*{acknowledgments}

\section*{references}

\end{document}

