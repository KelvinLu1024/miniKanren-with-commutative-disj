\documentclass[format=acmlarge, review=true, authordraft=true]{acmart}

%% scheme-list :
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}

\lstset{
  language=Scheme,
  basicstyle=\ttfamily,
  morekeywords={run,conde,run*,defrel,==,fresh},
  alsodigit={!\$\%&*+-./:<=>?@^_~},
  morecomment=[l]{;,\#{}lang},
  mathescape=true
}
%% scheme-list .

% metadata

\title{miniKanren with fair search strategies}
\author{Kuang-Chen Lu}
\affiliation{Indiana University}
\author{Weixi Ma}
\affiliation{Indiana University}
\author{Daniel P. Friedman}
\affiliation{Indiana University}



%%% NOTE %%%
%
%  SUBMISSION DEADLINE: May 15, 2019
%
%%%%%%%%%%%%


\newcommand{\conde}{\texttt{cond$^e$} }
\newcommand{\conj}{\texttt{conj}}
\newcommand{\disj}{\texttt{disj}}


\begin{document}

\begin{abstract}

%TODO our new searches also change the behavior of conj
The syntax of a programming language should reflect its semantics. When using a
disjunction operator in relational programming, a programmer would expect all
clauses of this disjunct to share the same chance of being explored, as
these clauses are written in parallel. The existing multi-arity disjunctive
operator in miniKanren, however, prioritize its clauses by the order of which
these clauses are written down. We have devised two new search strategies that
allocate computational effort more fairly in all clauses.

\end{abstract}

\maketitle

\section{introduction}

miniKanren programs, especially relational interpreters, have been proven to be useful in solving many problems \citep{byrd2017unified}. A subtlety in writing relational programs involving a large \conde expression, such as interpreters, is that the order of \conde clauses can affect the speed considerably.

Under the hood, \conde uses \texttt{conj} to combine goals within a clause, and \texttt{disj} to combine clauses. The \texttt{disj} in the current search strategy, interleaving DFS (iDFS), is unfair. It allocates half resource to its first goal, then allocates the other half to the rest similarly, except for the last clause that receives all the resource. This kind of \texttt{disj} prioritizes left clauses considerably in large \conde expressions.

Being aware of \texttt{disj} fairness, we also investigate \texttt{conj} fairness. 

We propose three new search strategies, balanced interleaving DFS (biDFS), which has almost fair \disj, fair DFS (fDFS), which has fair \disj, and breadth-first search (BFS), which has fair \disj and fair \conj. The almost fair \texttt{disj} (i.e. biDFS) doesn't always allocate resource evenly, however, the maximal ratio of resource is bounded by 2. Fair\texttt{disj} allocates resource evenly to goals in the same disjunct. BFS has both fair \texttt{disj} and fair \texttt{conj}, where answers are generated in increasing order of cost. We prove that our BFS is equivalent to the BFS proposed by Seres et al~\citep{seres1999algebra}. We also observe how new search strategies affect the efficiency and answer order of known miniKanren programs.

% Interleaving DFS, the search strategy of \conde in
% miniKanren~\citep{friedman_reasoned_2018}, allocates computational resource
% by the order in which the clauses are written. Each clause of a
% \conde takes half of the current resource and passes the other half
% to its following clauses, except for the last clause that takes all of the current resource. 
% The biased treatment provides both opportunity and burden: miniKanren users can place more frequently used 
% goal at the beginning to optimize their programs; however, it might be a 
% catastrophe if a goal that generates many useless states is placed before more 
% important goals. Seasoned miniKanreners usually know how to utilize 
% the unfairness to optimize their programs. However, we believe search strategies that is less sensitive to goal order can also be useful to little miniKanreners as well as seasoned ones. We propose two such search strategies, balanced interleaving DFS (biDFS) and breadth-first search (BFS), and observe how they affect the efficiency and the answer order of known miniKanren programs. The experiment is conducted with the miniKanren from \textit{The Reasoned Schemer, 2nd Edition}.

\section{fairness}

We illustrate how a fair search strategy should behavior by running a miniKanren relation, \texttt{repeato} (Fig.~\ref{repeato}), which relates a term \texttt{x} with a non-empty list whose elements are all \texttt{x}s.

\begin{figure}
	\lstinputlisting{Figures/repeato.rkt}
	\caption{\texttt{repeato} and an example run}
	\label{repeato}
\end{figure}

\subsection{fair \texttt{disj}}

In the following program, the three \conde clauses differs in trivial way. So we expect a search strategy with \emph{fair} \texttt{disj} would mix answers from each clause by grouping similar ones together. A search strategy is still considered fair if it permutes some lines of the answer list.

\begin{center}
	\begin{tabular}{c}
		\lstinputlisting{Figures/repeato-fair-disj.rkt}
	\end{tabular}
\end{center}

\texttt{disj} in iDFS is not fair. Each clause takes half of the current resource and passes the other half to its following clauses, except for the last clause that takes all the current resource. Running the same query results in an answer list with about half of it being lists of \texttt{a}.

\begin{center}
	\begin{tabular}{c}
		\lstinputlisting{Figures/repeato-iDFS.rkt}
	\end{tabular}
\end{center}

Our biDFS is almost fair. It gives a similar result in this case, except that the \texttt{b} clause takes most resource. 

\begin{center}
	\begin{tabular}{c}
		\lstinputlisting{Figures/repeato-biDFS-1.rkt}
	\end{tabular}
\end{center}

When the number of goals is a power of 2, biDFS would be fair. 

\begin{center}
	\begin{tabular}{c}
		\lstinputlisting{Figures/repeato-biDFS-2.rkt}
	\end{tabular}
\end{center}


\subsection{fair \texttt{conj}}

In the following program, the three \conde clauses differs in trivial way. So we expect a search strategy with \emph{fair} \texttt{conj} would mix answers derived from each clause by grouping similar ones together. A search strategy is still considered fair if it permutes some lines of the answer list. Strategies with unfair \conj produces more answers from the \texttt{a} clause. The result with biDFS is similar, except that \texttt{b} and \texttt{c} are swapped.

\begin{center}
	\begin{tabular}{c}
		\lstinputlisting{Figures/repeato-conj-1.rkt}
	\end{tabular}
\end{center}

The program above has finite intermediate states (associating \texttt{x} to \texttt{'a}, \texttt{'b}, or \texttt{'c} respectively). Therefore, the result is a ``fair'' mix (in the sense of fair \texttt{disj}) of the three search spaces derived from each intermediate state. However, this approach is not applicable when the number of intermediate states is infinite. A solution also taken in \citep{seres1999algebra} is to organize answers as a stream of list, where each list has finite answer. And a \emph{fair} \texttt{conj} should allocate resource evenly among search spaces derived from states in the same bag. 

A natural way to bag answers is by their costs. The \emph{cost} of an answer is the number of relation applications required to find them (their depth in search tree). In the previous examples, the costs of each answer is equal to their lengths. In the following example, the cost is equal to the length of inner list plus the length of outer list.

\begin{center}
	\begin{tabular}{c}
		\lstinputlisting{Figures/repeato-conj-2.rkt}
	\end{tabular}
\end{center}

% \section{fairness (old)}
% 
% A search strategy is \emph{fair} if answers of lower costs always come first. 
% The \emph{cost} of an answer is the number of relation applications. Now we 
% illustrate the costs of answers by running a miniKanren relation. 
% Fig.~\ref{repeato} defines a relation \texttt{repeato} which relates a term 
% \texttt{x} with a list whose elements are all \texttt{x}s.
% 
% %TODO compare our definition with Silvija's, Oleg's, and Edward's.
% 
% \begin{figure}
%   \lstinputlisting{Figures/defrel-repeato.rkt}
%   \caption{\texttt{repeato}}
%   \label{def-repeato}
% \end{figure}
% 
% Consider the following \texttt{run} of \texttt{repeato}.
% \begin{center}
%   \begin{tabular}{c}
%   \lstinputlisting{Figures/run-repeato-1.rkt}
%    \end{tabular}
% \end{center}
% 
% The above \texttt{run} generates 4 answers. All are lists of \texttt{*}s.
% The order of the answers reflects the order miniKanren discovers them:
% the first answer in the list is first discovered. This order is not surprising:
% to generate the first answer, \texttt{'()}, miniKanren needs to apply
% \texttt{repeato} only once and the later answers need more relation
% applications. In this example, the cost of each answer is the same as
% one more than the number of \texttt{*}s: the cost of \texttt{'()} is 1,
% the cost of \texttt{'(*)} is 2, and so on.
% 
% % A query result (list of answers) is in the \emph{cost-respecting} order if no 
% % answer occurs before another answer of a lower cost. In the above example, the 
% % result is cost-respecting. The iDFS search, however, does not generate 
% % cost-respecting answers in general. As an example, consider the following 
% % \texttt{run} of \texttt{repeato}.
% 
% In the above example, every search strategy looks fair. However, the following 
% example exposes that iDFS is not fair.
% 
% \begin{center}
%   \begin{tabular}{c}
%    \lstinputlisting{Figures/run-conde-repeato-iDFS.rkt}
%    \end{tabular}
% \end{center}
% 
% With iDFS, \texttt{'(a a)} occurs before \texttt{'(b)} while \texttt{'(a a)} is 
% associated with a higher cost. iDFS strategy is the cause since it prioritizes 
% the first \conde case considerably. When every \conde case 
% are equally productive, the iDFS strategy takes $1/2^{i}$ answers from the 
% $i$-th case, except the last case, which share the same portion as the second 
% last one. In contrast, the same run with BFS produces answers in an expected 
% order.
% 
% \begin{center}
%   \begin{tabular}{c}
%    \lstinputlisting{Figures/run-conde-repeato-BFS.rkt}
%    \end{tabular}
% \end{center}
% 
% Running the same query with biDFS results in yet another answer list. biDFS 
% essentially organize disjunctive goals into a balanced tree. There is no way to 
% build a balanced and complete tree of size 3, so one clause is allocated more 
% resource than the other two.
% 
% \begin{center}
% 	\begin{tabular}{c}
% 		\lstinputlisting{Figures/run-conde-repeato-biDFS.rkt}
% 	\end{tabular} 
% \end{center}
% 
% If one insert a \texttt{(nevero)} as the forth clause, this run would results 
% in the same answer list as the run with BFS. However, just making every \conde 
% has $2^n$ clauses cannot turn biDFS to BFS.
% 
% \begin{center}
% 	\begin{tabular}{c}
% 		\lstinputlisting{Figures/run-conde-repeato-biDFS-1.rkt}
% 	\end{tabular}
% \end{center}
 
\section{balanced interleaving DFS}

Our first solution, balanced interleaving DFS (biDFS), like iDFS, is not fair . However, it is less sensitive to goal order in disjunct and is as efficient as iDFS. 

The reason why iDFS's \texttt{disj} prioritizes its left goals considerably is that the \texttt{disj} applys \texttt{disj2} right associatively, and that 
\texttt{disj2} allocates resource evenly to its two sub-goals. If a disjunct 
is viewed as a binary tree where \texttt{disj2}s are nodes and sub-goals are 
leaves, the deeper a leaf locates, the lower resource it is shared. In iDFS, the tree is in one of the most unbalanced forms. 

The key idea of biDFS is to make the tree balanced. Fig.~\ref{balanced-disj} shows the difference between iDFS and biDFS. We introduce a function \texttt{disj*} and its helper \texttt{split}, and change the \texttt{disj} macro to call \texttt{disj*} immediately. \texttt{disj*} essentially construct a balanced \texttt{disj2} tree. The \texttt{split} helper splits elements of \texttt{ls} into two lists of roughly the same length, then apply \texttt{k} to the two sub-lists.

\begin{figure}
  \lstinputlisting{Figures/balanced-disj.rkt}
  \caption{\texttt{balanced-disj}}
  \label{balanced-disj}
\end{figure}

\section{fair DFS}

\section{breadth-first search}

In this section, we describe our BFS and compare it with the one from Seres et 
al \citep{seres1999algebra}. The first subsection is devoted to introducing BFS to miniKanren. This subsection results in a new version of miniKanren, \texttt{mk-1} (we call the original version \texttt{mk-0} for short). The second subsection describes the equivalent between \texttt{mk-1} and Silvija's BFS. In the third and last subsection, we optimize \texttt{mk-1} with the help of a queue, which results in \texttt{mk-2}, the final BFS version.

\subsection{change search strategy from iDFS to BFS}

In both \texttt{mk-0} and \texttt{mk-1}, search spaces are represented by 
streams of answers. Thunk streams in \texttt{mk-0} denote delayed 
computation, however, they do not necessarily mean an increment in cost. We use 
the same kind of stream in \texttt{mk-1} but only put thunk at those places 
where an increment in cost happens.

For convenience, we call the \texttt{car}s of a stream as its \emph{mature} 
part, and its last \texttt{cdr} as its \emph{immature} part. When the stream is 
definitely finite, its immature part is an empty list, otherwise, it is a 
thunk. We sometimes say a stream is immature to mean its mature part is empty.

Streams denote cost correctly when they are constructed by \texttt{==}, 
\texttt{succeed}, and \texttt{fail}. However, the \texttt{mk-0} version of 
\texttt{append-inf} (Fig.~\ref{append-inf-0}) breaks the rule when its first input stream, \texttt{s-inf}, has a non-trivial immature part. In this case, the resulting mature part contains only the mature part of \texttt{s-inf}. If we want to describe the cost information with thunks, the resulting mature part should also contain the mature part of \texttt{t-inf}.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-0.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-0}}
	 \label{append-inf-0}
\end{figure}

The \texttt{mk-1} version of \texttt{append-inf} (Fig.~\ref{append-inf-1}) 
gain fairness by combining the mature parts in the fashion of \texttt{append}. 
This \texttt{append-inf} calls its helper immediately, with the first argument, 
\texttt{s?}, set to \texttt{\#{}t}, which indicates whether \texttt{s-inf} and \texttt{t-inf} haven't been swapped in the driver. \texttt{s-inf} and \texttt{t-inf} are swapped in the third \texttt{cond} clause, where \texttt{s?} is flipped accordingly.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-1.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-1}}
	 \label{append-inf-1}
\end{figure}

\texttt{mk-1} is inefficient in two aspects. \texttt{append-inf} need to copy 
all \texttt{cons} cells of \emph{both} input streams when the first stream is 
has a non-trivial immature part. Besides, \texttt{mk-1} computes answers of the same cost at once, even when only a small portion is queried. We solve the two problems in the next subsections.


\subsection{compare our BFS with Seres's}

;; under construction


\subsection{optimize breadth-first search}

We avoid generating same-cost answers at once by expressing BFS with a queue, 
whose elements are thunks that return a new stream. Every \texttt{mk-1} stream has zero or one thunk, so it is uninteresting to manage them with the queue. Therefore, we change the representation of immature parts from thunks to 
thunk lists. As a side effect, it is no longer convenient to combine the mature and immature part with \texttt{append}, which would mix answers and thunks in the same list. We choose \texttt{cons} as an alternative to \texttt{append}.

After applying these two changes, stream representation becomes more 
complicated, which motivates us to set up an interface between stream 
and the rest of miniKanren. Listed in Fig.~\ref{interface} are all functions 
being aware of the stream representation, except \texttt{take-inf} and its helper function (they are explained later).

The first three functions are constructors: \texttt{empty-inf} makes an 
empty stream; \texttt{unit} makes a stream with one mature 
solution; \texttt{step} makes a stream with one thunk. 

\texttt{append-inf} combines each sub-parts with \texttt{append}.

\texttt{append-map-inf} ...

The next four functions are only depended on by \texttt{ifte} and \texttt{once}. \texttt{null-inf?} checks whether a stream is exhausted. \texttt{mature-inf?} checks whether a stream has some mature 
solutions. \texttt{car-inf} takes the first solution out of a mature stream. 
\texttt{cdr-inf} drops the first solution of a mature stream. Finally, 
\texttt{force-inf} forces an immature stream to do more computation.

\texttt{unit}, \texttt{append-map-inf}, \texttt{empty-inf} and 
\texttt{append-inf} form a \emph{MonadPlus}, where they correspond to 
\texttt{unit}, \texttt{bind}, \texttt{mzero}, and \texttt{mplus} respectively.

\begin{figure}
	 \lstinputlisting{Figures/interface.rkt}	
	 \caption{Functions being aware of stream representation}
	 \label{interface}
\end{figure}

The last interesting function is \texttt{take-inf} (Fig.~\ref{take-inf-3-1}). 
Its first parameter, \texttt{vs}, is a list of solutions. The next two parameters, \texttt{P} and \texttt{Q}, together represents a queue. 
The first two \texttt{cond} lines are very similar to their counterparts in mk-0 and mk-1. The third line runs when both the answer list \texttt{vs} and the queue are empty, which means we have found all the answers. The fourth line re-shape the queue. The last line invokes the first thunk in the queue and use the mature part of the resulting stream, \texttt{s-inf}, as the new \texttt{vs}, and enqueuing \texttt{s-inf}'s thunks. 

\begin{figure}
	 \lstinputlisting{Figures/take-inf-3-1.rkt}	
	 \caption{\texttt{take-inf} in \texttt{mk-3-1}}
	 \label{take-inf-3-1}
\end{figure}

\section{quantitative evaluation}

%TODO evalo (saying I love you), appendo, reverseo
;; Kuang-Chen and Weixi plan to put '(I love you), quines, appendo, and reverso here

\section{related works}

;; under construction

Edward points out a disjunct would be `fair' if its tree representation is balanced and full \citep{yang2010adventures}.

Silvija et al \citep{seres1999algebra} also describe a breadth-first search strategy. We proof their BFS is equivalent to ours. However, ours looks simpler and runs about twice faster in comparison with a straightforward translation of their Haskell code.

\section{conclusion}

\subsection{others}
%TODO contributions
%TODO future works

We devise a new search strategy, balanced interleaving DFS. The key idea is to 
make disjunct trees balanced. Changing the search strategy from iDFS to biDFS is not hard: 2 new functions and 1 modified macro. 

We also devise breadth-first search, whose intuition is similar to Seres's BFS.
And we have proved their equivalence. We optimize our BFS with a queue.

\section*{acknowledgments}

\bibliographystyle{ACM-Reference-Format}
\bibliography{citation}

\end{document}

