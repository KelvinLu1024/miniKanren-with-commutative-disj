\documentclass[format=acmlarge, review=true, authordraft=true]{acmart}

%% scheme-list :
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}

\lstset{
  language=Scheme,
  basicstyle=\ttfamily,
  morekeywords={run,conde,run*,defrel,==,fresh},
  alsodigit={!\$\%&*+-./:<=>?@^_~},
  morecomment=[l]{;,\#{}lang},
  mathescape=true
}
%% scheme-list .

% metadata

\title{BFS search in miniKanren}
\author{Kuang-Chen Lu}
\affiliation{Indiana University}
\author{Weixi Ma}
\affiliation{Indiana University}
\author{Daniel P. Friedman}
\affiliation{Indiana University}



%%% NOTE %%%
%
% - how to write scheme code
%
%   scheme-listing on GitHub
%   * use escapte to go back to latex world
%
% - plan paper writing
%   
%   * Abstract
%   * send to Dan
%   * Core Content
%     * how stream is implemented in TRS2's miniKanren
%     * how to do BFS search
%
% - how long does it usually take from drafting to submission
%
% - when is the deadline
%
%   last year submission deadline July 23, 2018
%
%%%%%%%%%%%%



% body
\begin{document}

\begin{abstract}

% background
% Translating Scheme programs to miniKanren programs is mostly mechanical. However,
% translation of cond deserves some attention, because conde generally prioritizes its left 
% clauses. For example, in a four-clauses conde expression, the first clause is searched 8 
% times more frequently than the last one.

The syntax of a programming language should reflect its semantics.
When using a disjunction operator in relational programming, a programmer would
expect all clauses of this disjunction to share the same chance of being explored,
as these clauses are written in parallel. The existing disjunctive operators in miniKanren,
however, prioritize their clauses by the order of which these clauses are written down.
% solution
We have devised a new search strategy that searches evenly in all clauses.
% evaluation
Based on our statistics, miniKanren slows down by a constant factor after applying our search strategy. (tested with very-recursiveo, need more tests)


\end{abstract}

\maketitle

\section{introduction}

OUTLINE:

( About miniKanren )

( Why the left clauses are explored more frequently? )

( How to solve the problem? )

( Summary of later sections )

\section{cost of answers}

%TODO the meaning of resolution step in Silvija Seres's paper
%TODO REPLize comment

The \emph{cost} of an answer is the number of relation applications needed to find the answer. We use the miniKanren program, \texttt{repeato}, in Fig.~\ref{repeato-1} to demonstrate the cost of answers. We borrow this idea from Silvija Seres's work [*]. \texttt{repeato} relates \texttt{x} with a list whose elements are all \texttt{x}s. The run expression uses \texttt{repeato} to generate 4 lists whose elements are all \texttt{*}s. The order of the answers reflects the order miniKanren discovers them. The leftmost answer is discovered first. The order here is not suprising: to generate the answer \texttt{'()}, miniKanren needs to apply \texttt{repeato} only once. And it needs more applications of \texttt{repeato} to find the later answers that are more complicated.

\begin{figure}
  \lstinputlisting{Code/repeat.rkt}
  \caption{\texttt{repeato}}
  \label{repeato-1}
\end{figure}

%TODO relation *application*
%TODO split figure 2 into 2 figures
%TODO define iDFS = interleaving DFS in Introduction
%TODO (define "cost-repsecting" "in order of increasing cost")
In the  example above, the cost of each answer is the same as one more than the number of \texttt{*}s. No answer of zero cost exists. For this \texttt{run}, both search strategies produces answers in increasing order of costs. In more complicated cases, however, interleaving DFS does not always produces answers of lower costs first. For instance, the \texttt{run} in Fig.~\ref{repeato-2} uses the iDFS strategy to produce answers in a seemingly random order. The answers listed by iDFS are a blend of three kinds, i.e., lists of \texttt{a}s, lists of \texttt{b}s, and lists of \texttt{c}s. The answers of this \texttt{run} is not cost-respecting, although each kind of answer is cost-respecting.  
 
%TODO lafalf

However, the blended answers tends to include more answers from the first conde line, i.e. from (repeato 'a q). In general, iDFS prioritizes the left conde clauses.

\begin{figure}
	\lstinputlisting{Code/repeat-abc.rkt}
	\caption{\texttt{repeato}}
	\label{repeato-2}
\end{figure}



\section{change search strategy}

Now we change the search strategy and optimize the system in three steps. The result of these steps are mk-1, mk-2, and mk-3 respectively. The initial miniKanren is named mk-0, which is the miniKanren in TRS2.

\subsection{representation of search space}

In mk-0, search space is represented by streams. Streams can be finite or infinite. Finite streams are just lists. And infinite streams are improper lists, whose last cdr is a procedure which takes no arguments and returns a stream when involked. Cars of streams are (possibly incomplete) answers. We call the cars the mature part, and the last cdr the immature part.

(connect stream with cost)

\subsection{initial version}

(explain mk-0's append-inf)

\lstinputlisting{Code/append-inf-trs2.rkt}

To make the search BFS, we just need to have append-inf combines mature parts in the fashion of append, and combine non-empty immature parts by contructing a new procedure.

\lstinputlisting{Code/append-inf-bfs-loop.rkt}

\subsection{stepstone of optimization}

Make irrelevant parts in mK representation-independent w.r.t. search space, and combine mature part and immature part with cons.

\subsection{optimization}

The goal is to express BFS explicitly with queue, so that we donâ€™t have to generate all answers of the same cost at once.

Interesting changes: (1) put thunks in a list; (2) change force-inf (introduced in 4.B) so that it can make progress in all thunks (3) use a queue to manage thunks in take-inf.

\section{conclusion}

\section*{acknowledgments}

\section*{references}

\end{document}

