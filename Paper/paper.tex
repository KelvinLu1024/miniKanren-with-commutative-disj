\documentclass[format=acmlarge, review=true, authordraft=true]{acmart}

%% scheme-list :
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}

\lstset{
  language=Scheme,
  basicstyle=\ttfamily,
  morekeywords={run,conde,run*,defrel,==,fresh},
  alsodigit={!\$\%&*+-./:<=>?@^_~},
  morecomment=[l]{;,\#{}lang},
  mathescape=true
}
%% scheme-list .

% metadata

\title{BFS search in miniKanren}
\author{Kuang-Chen Lu}
\affiliation{Indiana University}
\author{Weixi Ma}
\affiliation{Indiana University}
\author{Daniel P. Friedman}
\affiliation{Indiana University}



%%% NOTE %%%
%
% - plan paper writing
%   
%   * Abstract
%   * send to Dan
%   * Core Content
%     * how stream is implemented in TRS2's miniKanren
%     * how to do BFS search
%
% - when is the deadline
%
%   last year submission deadline July 23, 2018
%
%%%%%%%%%%%%



% body
\begin{document}

\begin{abstract}

The syntax of a programming language should reflect its semantics.
When using a disjunction operator in relational programming, a programmer would
expect all clauses of this disjunction to share the same chance of being explored,
as these clauses are written in parallel. The existing disjunctive operators in miniKanren,
however, prioritize their clauses by the order of which these clauses are written down.
We have devised a new search strategy that searches evenly in all clauses.
Based on our statistics, miniKanren slows down by a constant factor after applying our search strategy.
(tested with very-recursiveo, need more tests)


\end{abstract}

\maketitle

\section{introduction}

OUTLINE:

( About miniKanren )

( Why the left clauses are explored more frequently? )

%TODO define iDFS = interleaving DFS in Introduction

( How to solve the problem? )

( Summary of later sections )

\section{cost of answers}

%TODO the meaning of resolution step in Silvija Seres's paper

The \emph{cost} of an answer is the number of relation applications needed to
find the answer. This idea is borrowed from Silvija Seres's work [*].
Now we illustrate the costs of answers by running a miniKanren relation.
Fig.~\ref{def-repeato} defines the relation \texttt{repeato} that 
relates a term \texttt{x} with a list whose elements are all \texttt{x}s.

\begin{figure}
  \lstinputlisting{Figures/defrel-repeato.rkt}
  \caption{\texttt{repeato}}
  \label{def-repeato}
\end{figure}

Consider the following \texttt{run} of \texttt{repeato}.
\begin{center}
  \begin{tabular}{c}
  \lstinputlisting{Figures/run-repeato-1.rkt}
   \end{tabular}
\end{center}

The above \texttt{run} generates 4 answers. All are lists of \texttt{*}s.
The order of the answers reflects the order miniKanren discovers them:
the leftmost answer is the first one. This result is not suprising:
to generate the first answer, \texttt{'()}, miniKanren needs to apply
\texttt{repeato} only once and the later answers need more recursive
applications. In this example, the cost of each answer is the same as
one more than the number of \texttt{*}s. The cost of \texttt{'()} is 1,
the cost of \texttt{'(*)} is 2, etc.

A list of answer is in the \emph{cost-respecting} order if no answer occurs
before another answer of a lower cost. In the above example, the answers are
cost-respecting. The iDFS search, however, does not generate cost-respecting
answers in general. As an example, consider the following \texttt{run} of
\texttt{repeato}.
\begin{center}
  \begin{tabular}{c}
   \lstinputlisting{Figures/run-conde-repeato-iDFS.rkt}
   \end{tabular}
\end{center}

The results are not cost-respecting. For example, \texttt{'(a a)} occurs before
\texttt{'(b)} while \texttt{'(a a)} is associated with a higher cost. 
The problem is that iDFS strategy prioritizes the first \texttt{conde} case
considerablely. In general, when every conde case are equally productive, the iDFS
strategy takes $1/2^{i}$ answers from the $i$-th case, except the last case,
which share the same portion as the second last.



%TODO relation *application*

For the above \texttt{run}, both search strategies produces answers in increasing order of costs, i.e. both of them are \emph{cost-respecting}. In more complicated cases, however, interleaving DFS does not always produces answers in cost-repecting order. For instance, with iDFS the \texttt{run} in Fig.~\ref{conde-repeato-iDFS} produces answers in a seemingly random order. In contrast, the same run with BFS produces answers in an expected order (Fig.~\ref{conde-repeato-BFS}).


\lstinputlisting{Figures/run-conde-repeato-BFS.rkt}



\section{change search strategy}

Now we change the search strategy and optimize the system. The whole process is completed in three steps, corresponding to 4 versions of miniKanren. The initial version, \texttt{mk-0}, is exactly the miniKanren in \emph{The Reasoned Schemer, 2nd Edition}.

\subsection{from \texttt{mk-0} to \texttt{mk-1}}

In \texttt{mk-0} and \texttt{mk-1}, search spaces are represented by streams of answers. Streams can be finite or infinite. Finite streams are just lists. And infinite streams are improper lists, whose last \texttt{cdr} is a thunk returning another stream. We call the \texttt{car}s the \emph{mature} part, and the last \texttt{cdr} the \emph{immature} part. 

Streams are cost respective when they are initially constructed by \texttt{==}. However, the \texttt{mk-0} version of \texttt{append-inf} (Fig.~\ref{append-inf-0}), a composer of stream, can break cost respectiveness. when its first argument, \texttt{s-inf} is infinite. The resulting mature part contains only the mature part of \texttt{s-inf}. The whole \texttt{t-inf} goes to the resulting immature part -- the newly constructed thunk.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-0.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-0}}
	 \label{append-inf-0}
\end{figure}


The \texttt{mk-1} version of \texttt{append-inf} (Fig.~\ref{append-inf-1}) restores cost-respectiveness by combining the mature parts in the fashion of \texttt{append}. \texttt{append-inf} calls its helper immediately, with the first argument, \texttt{s?}, set to \texttt{\#{}t}, which means \texttt{s-inf} in the helper is the \texttt{s-inf} in the driver. Two streams are swapped in the third \texttt{cond} clause, where \texttt{s?} is also changed accordingly.

\begin{figure}
	 \lstinputlisting{Figures/append-inf-1.rkt}	
	 \caption{\texttt{append-inf} in \texttt{mk-1}}
	 \label{append-inf-1}
\end{figure}

\texttt{mk-1} is not efficient in two aspects. \texttt{append-inf} need to copy all \texttt{cons} cells of two input stream when the first one is infinite. Besides, \texttt{mk-1} generates answers of the same cost at once, even when only a small portion is queried. We solves the two problems in the next two subsections.

\subsection{stepstone of optimization}

(eqv to Seres's BFS ?)

Make irrelevant parts in mK representation-independent w.r.t. search space, and combine mature part and immature part with cons.

\subsection{optimization}

The goal is to express BFS explicitly with queue, so that we donâ€™t have to generate all answers of the same cost at once.

Interesting changes: (1) put thunks in a list; (2) change force-inf (introduced in 4.B) so that it can make progress in all thunks (3) use a queue to manage thunks in take-inf.

\section{conclusion}

\section*{acknowledgments}

\section*{references}

\end{document}

