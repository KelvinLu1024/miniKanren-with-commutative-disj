#lang racket(provide (all-defined-out))#| mk-all-in-onegive run an additional argument |#;; Reader monad(define (return a)  (lambda (v)    a))(define (bind ma sequel)  (lambda (v)    (let ([a (ma v)])      (let ([mb (sequel a)])        (mb v)))))(define (mrun ma v) (ma v))(define (ask)  (lambda (v) v))(define-syntax letM  (syntax-rules ()    [(letM () body) body]    [(letM ([x ma] pr ...) body)     (bind ma (lambda (x) (letM (pr ...) body)))]));; Search Space(define (none)   `())(define (unit s) `(,s))(define-syntax step  (syntax-rules ()    [(step s-inf) (lambda () s-inf)]))#| Space × (State × Space → Space) × (→ Space) → Space |#(define (which-inf s-inf kf ks)  (cond    [(null? s-inf) (kf)]    [(pair? s-inf) (ks (car s-inf) (cdr s-inf))]    [else (step (which-inf (s-inf) kf ks))]))(define var (lambda (x) (vector x)))(define var? (lambda (x) (vector? x)))(define empty-s '())(define (walk v s)  (let ((a (and (var? v) (assv v s))))    (cond      ((pair? a) (walk (cdr a) s))      (else v))))(define (ext-s x v s)  (cond    ((occurs? x v s) #f)    (else (cons `(,x . ,v) s))))(define (occurs? x v s)  (let ((v (walk v s)))    (cond      ((var? v) (eqv? v x))      ((pair? v)        (or (occurs? x (car v) s)           (occurs? x (cdr v) s)))      (else #f))))(define (unify u v s)  (let ((u (walk u s)) (v (walk v s)))    (cond      ((eqv? u v) s)      ((var? u) (ext-s u v s))      ((var? v) (ext-s v u s))      ((and (pair? u) (pair? v))       (let ((s (unify (car u) (car v) s)))         (and s           (unify (cdr u) (cdr v) s))))      (else #f))))(define (== u v)  (return    (lambda (s)      (let ((s (unify u v s)))        (if s (unit s) (none))))))(define succeed  (return (lambda (s) (unit s)))) (define fail  (return (lambda (s) (none))))(define (disj2 mg1 mg2)  (letM ([g1 mg1] [g2 mg2])    (return (lambda (s) (append-inf (g1 s) (g2 s))))))(define (disj2/fair mg1 mg2)  (letM ([g1 mg1] [g2 mg2])    (return (lambda (s) (append-inf/fair (g1 s) (g2 s))))))(define (append-inf s-inf t-inf)  (cond    ((null? s-inf) t-inf)    ((pair? s-inf)     (cons (car s-inf)       (append-inf (cdr s-inf) t-inf)))    (else (lambda ()             (append-inf t-inf (s-inf))))))(define (append-inf/fair s-inf t-inf)  (let loop ([s? #t]             [s-inf s-inf]             [t-inf t-inf])    (cond      ((pair? s-inf)       (cons (car s-inf)         (loop s? (cdr s-inf) t-inf)))      ((null? s-inf) t-inf)      (s? (loop #f t-inf s-inf))      (else (step (loop #t (t-inf) (s-inf)))))))(define (take-inf n s-inf)  (cond    ((and n (zero? n)) '())    ((null? s-inf) '())    ((pair? s-inf)      (cons (car s-inf)       (take-inf (and n (sub1 n))         (cdr s-inf))))    (else (take-inf n (s-inf)))))(define (conj2 mg1 mg2)  (letM ([g1 mg1] [g2 mg2]         [SS (ask)])    (case SS      [(BFS)       (return         (lambda (s) (append-map-inf/fair g2 (g1 s))))]      [(DFSi DFSbi DFSf)       (return         (lambda (s) (append-map-inf g2 (g1 s))))]      [else       (error "unrecognized search strategy ~a" SS)])))(define (append-map-inf/fair g s-inf)  (which-inf s-inf    (lambda () (none))    (lambda (s t-inf)      (append-inf/fair (g s)        (append-map-inf/fair g t-inf)))))(define (append-map-inf g s-inf)  (which-inf s-inf    (lambda () (none))    (lambda (s t-inf)      (append-inf (g s)        (append-map-inf g t-inf)))))(define (call/fresh name f)  (f (var name)))(define (reify-name n)  (string->symbol    (string-append "_"      (number->string n))))(define (walk* v s)  (let ((v (walk v s)))    (cond      ((var? v) v)      ((pair? v)       (cons         (walk* (car v) s)         (walk* (cdr v) s)))      (else v)))); 'project' is defined in the frame 10:98 on page 166.(define-syntax project  (syntax-rules ()    ((project (x ...) mg ...)     (letM ([SS (ask)])       (return         (lambda (s)           (let ((x (walk* x s)) ...)             ((mrun (conj mg ...) SS) s))))))))(define (reify-s v r)  (let ((v (walk v r)))    (cond      ((var? v)       (let ((n (length r)))         (let ((rn (reify-name n)))           (cons `(,v . ,rn) r))))      ((pair? v)       (let ((r (reify-s (car v) r)))         (reify-s (cdr v) r)))      (else r))))(define (reify v)  (lambda (s)    (let ((v (walk* v s)))      (let ((r (reify-s v empty-s)))        (walk* v r)))))(define (run-goal n g)  (take-inf n (g empty-s)))(define (ifte mg1 mg2 mg3)  (letM ([g1 mg1] [g2 mg2] [g3 mg3]         [SS (ask)])    (case SS      [(BFS)       (return         (lambda (s)           (which-inf (g1 s)             (lambda () (g3 s))             (lambda (s0 s-inf)               (append-map-inf/fair g2                 (append-inf/fair (unit s0) s-inf))))))]      [(DFSi DFSbi DFSf)       (return         (lambda (s)           (which-inf (g1 s)             (lambda () (g3 s))             (lambda (s0 s-inf)               (append-map g2                 (append-inf (unit s0) s-inf))))))]      [else       (error "unrecognized search strategy ~a" SS)])))(define (once mg)  (letM ([g mg])    (return      (lambda (s)        (which-inf (g s)          (lambda () (none))          (lambda (s0 s-inf) (unit s0)))))))(define (split ls k)  (cond    [(null? ls) (k '() '())]    [else (split (cdr ls)            (λ (l1 l2)              (k (cons (car ls) l2) l1)))]))(define (disj* mgs)  (letM ([SS (ask)])    (case SS      [(DFSbi)       (let rec ([mgs mgs])         (cond           [(null? (cdr mgs)) (car mgs)]           [else            (split mgs              (lambda (mgs1 mgs2)                (disj2 (rec mgs1) (rec mgs2))))]))]      [(DFSi)       (foldr         (lambda (mg1 mg2)           (if mg2 (disj2 mg1 mg2) mg1))         #f mgs)]      [(DFSf BFS)       (foldr         (lambda (mg1 mg2)           (if mg2 (disj2/fair mg1 mg2) mg1))         #f mgs)]      [else       (error "unrecognized search strategy ~a" SS)])));;; Here are the key parts of Appendix A(define-syntax disj  (syntax-rules ()    [(disj) fail]    [(disj mg ...) (disj* (list mg ...))]))(define-syntax conj  (syntax-rules ()    ((conj) succeed)    ((conj mg) mg)    ((conj mg0 mg ...) (conj2 mg0 (conj mg ...)))))(define-syntax defrel  (syntax-rules ()    ((defrel (name x ...) mg ...)     (define (name x ...)       (letM ([SS (ask)])         (return           (lambda (s)             (step ((mrun (conj mg ...) SS) s)))))))))(define-syntax run  (syntax-rules ()    ((run SS n (x0 x ...) mg ...)     (run SS n q (fresh (x0 x ...)                   (== `(,x0 ,x ...) q) mg ...)))    ((run SS n q mg ...)     (let ((q (var 'q)))       (map (reify q)         (run-goal n (mrun (conj mg ...) 'SS)))))))(define-syntax run*  (syntax-rules ()    ((run* SS q g ...) (run SS #f q g ...))))(define-syntax fresh  (syntax-rules ()    ((fresh () mg ...) (conj mg ...))    ((fresh (x0 x ...) mg ...)     (call/fresh 'x_0       (lambda (x0)         (fresh (x ...) mg ...))))))(define-syntax conde  (syntax-rules ()    ((conde (mg ...) ...)     (disj (conj mg ...) ...))))(define-syntax conda  (syntax-rules ()    ((conda (mg0 mg ...)) (conj mg0 mg ...))    ((conda (mg0 mg ...) ln ...)     (ifte mg0 (conj mg ...) (conda ln ...)))))(define-syntax condu  (syntax-rules ()    ((condu (mg0 mg ...) ...)     (conda ((once mg0) mg ...) ...))))