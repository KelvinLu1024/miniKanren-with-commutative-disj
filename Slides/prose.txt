## Towards a miniKanren with fair search strategies

Hello everyone, I am Kuang-Chen, from Indiana University. It is my pleasure to 
be here, the first miniKanren workshop. We are going to talk about our paper,
Towards a miniKanren with fair search strategies.

miniKanren is quite a big family of programming languages. So where did we 
start to move towards our goal?



## Where to start?

We started with the implementation described in this book, TRS2. We chose 
the yellow-green book because it was my first introduction to miniKanren, and I 
found its implementation to be easy to understand.



## What is fairness?

So, what is fairness?

We think there are two aspects of fairness:
* fairness in disj, and
* fairness in conj

And there are three levels of disj fairness and two levels of conj fairness.

We will discuss these later. After showing some example programs.


## Examples

We are going to elaborate fairness with the relation repeato. repeato  
relates x with a list xs which includes one or more xs.

(next slide)

For example, in this query, we ask for 3 q such that q is a list of one or more 
lambdas. miniKanren gives us back three answers: a list of one lambda, a
a list of two lambdas, and so on.



## Fairness in Disjunctions

Sometimes we want lists of other things. Here we ask for 9 q such that q 
is either a lists of lambdas, or a list of female lambs, or a list of male 
lambs.

(next slide)

The current search strategy in the yellow-green book gives many more lambdas 
than lambs. Why is it? This is because the disjunction of this search strategy 
is unfair.

We use the word ``disjunction'' because conde relates its clauses disjunctively. 
To put it another way, these three repeatos are conceptually related by logical 
OR.

(next slide)

Let's ask the same question to a miniKanren with almost-fair disjunction.  This 
time we get many more female lambs than other things.  The result might look 
not better than the unfair one.  However, as the number of conde clauses 
increases, things will be different. 



## Compare fair and almost-fair

For example, if we add two more clauses to this conde, the current strategy
still gives us many lambdas. 

(next slide)

In contrast, the strategy with almost-fair disjunction would give us the 
same number of three sorts of answers, and the other two sorts less frequently.

Almost-fair disjunction guarantees that the maximal ratio of computational 
resources spent in each clause is bounded by a constant, no matter how many 
clauses are there. The constant for our strategy is 2. Here the lamb clauses 
and the cow clause are allocated twice as many resources as the other two 
clauses.




## Fairness in Disjunctions (again)

Strategies with fair disjunctions provide an even stronger guarantee. That is 
resources are allocated completely evenly to every clause in the same conde. 
Thus, the answers are generated in a more understandable order.



## (Search) Space

Before explaining fairness in conjunctions, we will introduce spaces first.  
Spaces are like streams.

Search strategies determine how to organize states in spaces. All our strategies 
share the same Space structure.  But we reformulating space representation in a 
search strategy to improve execution time.

A space is either an empty list, a pair of a state and a space, or a suspension.

(next slides)

We visualize spaces like these examples.

In the first diagram, the space starts with a state -- 
we represent all states as squares, possibly with color. That state is 
followed by a gray rectangle, which means everything after it is in a 
suspension.  Within the suspension there are two more states followed by
a black rectangle. The black rectangle represents a null and terminates the 
space.

The second diagram shows a possibly infinite space. Although spaces can be 
infinitely large, the number of squares between any two gray rectangles is 
always finite.



## Fairness in Conjunctions

Now let's talk about fairness in conjunction.

Fairness in conjunctions is different from fairness in disjunctions. When we 
consider fairness in disjunctions, we are looking for fair multi-arity 
disjunction. In the case of conjunctions, however, we only care about binary 
conjunction.

A binary conjunction has two relations to satisfy.
In the left-side of the diagram, the space displayed vertically is the result of 
satisfying the first conjunct, or the first relation of the conjunction. We 
want each state to also satisfy the second conjunct. So we have more spaces
to the right. Each horizontal space corresponds to a state in the vertical
space. Every state in the horizontal spaces satisfies both 
relations, thus they comprise a solution to this conjunction.

The key point of fair conjunction is to combine horizontal
spaces of the same color fairly, as we did for fair disjunction.



## Search Strategies

Here are all 4 search strategies we analyzed. 
Interleaving DFS is the current search strategy in the yellow-green book.
Balanced interleaving DFS and fair DFS are new.

We give a new implementation of BFS.
Ours is shorter and more efficient than the one presented in "Algebra of Logic 
Programming"



## Why fairness?

But... why do we want fairness?

We have three reasons.

First, as we have seen in the repeato examples, fair strategies can 
sometimes generate answers in a more understandable order.

Second, the performance of search strategies with fair or almost-fair  
disjunction is more resistant to permuting conde clauses.

As a corollary, beginner need not be too worried about clause order.
As a corollary again, programmers sometimes run a relation in several modes.
But the optimal orders for each mode can be different.  Then, fair
strategies allow using one definition for different running modes while having 
``acceptable'' performance.

## Q & A

That's all. Thanks!




(*

When you don't know how to answer a question ...
    "Let's take that discussion offline."
*)
